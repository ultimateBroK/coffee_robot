# üéÆ H∆Ø·ªöNG D·∫™N CHI TI·∫æT FILE COFFEE_ROBOT.CPP

## üìã M·ª•c l·ª•c
- [T·ªïng quan](#t·ªïng-quan)
- [C·∫•u tr√∫c file](#c·∫•u-tr√∫c-file)
- [H·ªá th·ªëng Camera](#h·ªá-th·ªëng-camera)
- [H·ªá th·ªëng ƒëi·ªÅu khi·ªÉn](#h·ªá-th·ªëng-ƒëi·ªÅu-khi·ªÉn)
- [H·ªá th·ªëng Lighting](#h·ªá-th·ªëng-lighting)
- [H·ªá th·ªëng Rendering](#h·ªá-th·ªëng-rendering)
- [Animation Loop](#animation-loop)
- [C√°ch thay ƒë·ªïi camera v√† g√≥c nh√¨n](#c√°ch-thay-ƒë·ªïi-camera-v√†-g√≥c-nh√¨n)
- [C√°ch thay ƒë·ªïi controls](#c√°ch-thay-ƒë·ªïi-controls)
- [C√°ch thay ƒë·ªïi √°nh s√°ng v√† m√†u s·∫Øc](#c√°ch-thay-ƒë·ªïi-√°nh-s√°ng-v√†-m√†u-s·∫Øc)
- [C√°ch thay ƒë·ªïi giao di·ªán](#c√°ch-thay-ƒë·ªïi-giao-di·ªán)
- [V√≠ d·ª• t√πy ch·ªânh](#v√≠-d·ª•-t√πy-ch·ªânh)
- [Troubleshooting](#troubleshooting)

## üéØ T·ªïng quan

File `coffee_robot.cpp` l√† **main application file** ch·ª©a:
- **OpenGL Setup**: Kh·ªüi t·∫°o 3D graphics engine
- **Camera System**: ƒêi·ªÅu khi·ªÉn g√≥c nh√¨n 3D
- **Input Handling**: X·ª≠ l√Ω b√†n ph√≠m v√† chu·ªôt
- **Animation Loop**: V√≤ng l·∫∑p c·∫≠p nh·∫≠t v√† v·∫Ω
- **UI System**: Hi·ªÉn th·ªã tr·∫°ng th√°i v√† h∆∞·ªõng d·∫´n
- **Window Management**: Qu·∫£n l√Ω c·ª≠a s·ªï OpenGL

## üìÅ C·∫•u tr√∫c file

```
coffee_robot.cpp
‚îú‚îÄ‚îÄ Global Variables (Camera & Input)
‚îú‚îÄ‚îÄ OpenGL Initialization
‚îÇ   ‚îú‚îÄ‚îÄ initGL() - Setup lighting, depth test
‚îÇ   ‚îî‚îÄ‚îÄ reshape() - Handle window resize
‚îú‚îÄ‚îÄ Main Rendering
‚îÇ   ‚îú‚îÄ‚îÄ display() - Main draw function
‚îÇ   ‚îî‚îÄ‚îÄ Text rendering system
‚îú‚îÄ‚îÄ Input System
‚îÇ   ‚îú‚îÄ‚îÄ keyboard() - Handle keys
‚îÇ   ‚îú‚îÄ‚îÄ mouse() - Handle mouse clicks
‚îÇ   ‚îú‚îÄ‚îÄ mouseMotion() - Handle mouse drag
‚îÇ   ‚îî‚îÄ‚îÄ specialKeys() - Handle arrow keys
‚îú‚îÄ‚îÄ Animation System
‚îÇ   ‚îî‚îÄ‚îÄ timer() - 60 FPS animation loop
‚îú‚îÄ‚îÄ Utility Functions
‚îÇ   ‚îú‚îÄ‚îÄ printInstructions()
‚îÇ   ‚îî‚îÄ‚îÄ cleanup()
‚îî‚îÄ‚îÄ main() - Program entry point
```

## üì∑ H·ªá th·ªëng Camera

### üéõÔ∏è Bi·∫øn camera to√†n c·ª•c
```cpp
float cameraAngleX = -25.0f;  // G√≥c nh√¨n t·ª´ tr√™n xu·ªëng (√¢m ƒë·ªÉ nh√¨n xu·ªëng)
float cameraAngleY = 45.0f;   // G√≥c nh√¨n ch√©o 
float cameraDistance = 15.0f; // Kho·∫£ng c√°ch ph√π h·ª£p
bool mousePressed = false;
int lastMouseX, lastMouseY;
```

### üìä √ù nghƒ©a t·ª´ng bi·∫øn:

| Bi·∫øn | M·ª•c ƒë√≠ch | Gi√° tr·ªã m·∫∑c ƒë·ªãnh | ·∫¢nh h∆∞·ªüng |
|------|----------|------------------|-----------|
| `cameraAngleX` | G√≥c xoay theo tr·ª•c X (l√™n/xu·ªëng) | -25.0f | √Çm = nh√¨n t·ª´ tr√™n xu·ªëng |
| `cameraAngleY` | G√≥c xoay theo tr·ª•c Y (tr√°i/ph·∫£i) | 45.0f | D∆∞∆°ng = nh√¨n ch√©o |
| `cameraDistance` | Kho·∫£ng c√°ch t·ª´ camera ƒë·∫øn robot | 15.0f | TƒÉng = xa h∆°n, gi·∫£m = g·∫ßn h∆°n |
| `mousePressed` | Tr·∫°ng th√°i chu·ªôt | false | true khi ƒëang k√©o chu·ªôt |

### üéÆ C√°ch camera ho·∫°t ƒë·ªông trong display():
```cpp
void display() {
    // Setup camera transformation
    glTranslatef(0.0f, 0.0f, -cameraDistance);  // Di chuy·ªÉn camera ra xa
    glRotatef(cameraAngleX, 1.0f, 0.0f, 0.0f); // Xoay theo X (l√™n/xu·ªëng)
    glRotatef(cameraAngleY, 0.0f, 1.0f, 0.0f); // Xoay theo Y (tr√°i/ph·∫£i)
}
```

## üéÆ H·ªá th·ªëng ƒëi·ªÅu khi·ªÉn

### ‚å®Ô∏è Keyboard Controls
```cpp
void keyboard(unsigned char key, int x, int y) {
    switch (key) {
        case ' ':    // Space - b·∫Øt ƒë·∫ßu pha c√† ph√™
        case 'r':    // R - reset robot
        case 'R':    // R - reset robot (ch·ªØ hoa)
        case 27:     // ESC - tho√°t ch∆∞∆°ng tr√¨nh
    }
}
```

### üñ±Ô∏è Mouse Controls
```cpp
void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON) {
        if (state == GLUT_DOWN) {
            mousePressed = true;     // B·∫Øt ƒë·∫ßu k√©o
            lastMouseX = x;         // L∆∞u v·ªã tr√≠ chu·ªôt
            lastMouseY = y;
        } else {
            mousePressed = false;    // K·∫øt th√∫c k√©o
        }
    }
}
```

### üñ±Ô∏è Mouse Motion (K√©o chu·ªôt ƒë·ªÉ xoay camera)
```cpp
void mouseMotion(int x, int y) {
    if (mousePressed) {
        float deltaX = x - lastMouseX;  // ƒê·ªô di chuy·ªÉn ngang
        float deltaY = y - lastMouseY;  // ƒê·ªô di chuy·ªÉn d·ªçc
        
        cameraAngleY += deltaX * 0.5f;  // Xoay camera ngang
        cameraAngleX += deltaY * 0.5f;  // Xoay camera d·ªçc
        
        // Gi·ªõi h·∫°n g√≥c camera
        if (cameraAngleX > 90.0f) cameraAngleX = 90.0f;   // Kh√¥ng xoay qu√° 90¬∞
        if (cameraAngleX < -90.0f) cameraAngleX = -90.0f; // Kh√¥ng xoay qu√° -90¬∞
    }
}
```

### üîº Special Keys (Ph√≠m m≈©i t√™n ƒë·ªÉ zoom)
```cpp
void specialKeys(int key, int x, int y) {
    switch (key) {
        case GLUT_KEY_UP:
            cameraDistance -= 1.0f;                        // Zoom in
            if (cameraDistance < 5.0f) cameraDistance = 5.0f;  // Gi·ªõi h·∫°n g·∫ßn nh·∫•t
            break;
        case GLUT_KEY_DOWN:
            cameraDistance += 1.0f;                         // Zoom out
            if (cameraDistance > 30.0f) cameraDistance = 30.0f; // Gi·ªõi h·∫°n xa nh·∫•t
            break;
    }
}
```

## üí° H·ªá th·ªëng Lighting

### üåü Kh·ªüi t·∫°o √°nh s√°ng trong initGL()
```cpp
void initGL() {
    glEnable(GL_DEPTH_TEST);        // B·∫≠t depth testing (v·∫≠t g·∫ßn che v·∫≠t xa)
    glEnable(GL_LIGHTING);          // B·∫≠t h·ªá th·ªëng √°nh s√°ng
    glEnable(GL_LIGHT0);            // B·∫≠t ƒë√®n s·ªë 0
    glEnable(GL_COLOR_MATERIAL);    // Cho ph√©p m√†u v·∫≠t li·ªáu
    glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE); // C√†i ƒë·∫∑t material
    
    // Thi·∫øt l·∫≠p √°nh s√°ng
    GLfloat lightPos[] = {5.0f, 10.0f, 5.0f, 1.0f};      // V·ªã tr√≠ ƒë√®n
    GLfloat lightColor[] = {1.0f, 1.0f, 1.0f, 1.0f};     // M√†u ƒë√®n (tr·∫Øng)
    GLfloat ambientLight[] = {0.3f, 0.3f, 0.3f, 1.0f};   // √Ånh s√°ng m√¥i tr∆∞·ªùng
    
    glLightfv(GL_LIGHT0, GL_POSITION, lightPos);          // ƒê·∫∑t v·ªã tr√≠ ƒë√®n
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightColor);         // ƒê·∫∑t m√†u khu·∫øch t√°n
    glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight);       // ƒê·∫∑t √°nh s√°ng m√¥i tr∆∞·ªùng
    
    glClearColor(0.5f, 0.7f, 1.0f, 1.0f); // M√†u n·ªÅn xanh da tr·ªùi nh·∫°t
}
```

### üîß √ù nghƒ©a t·ª´ng th√¥ng s·ªë √°nh s√°ng:

| Th√¥ng s·ªë | √ù nghƒ©a | Gi√° tr·ªã | ·∫¢nh h∆∞·ªüng |
|----------|---------|---------|-----------|
| `lightPos` | V·ªã tr√≠ ƒë√®n trong kh√¥ng gian 3D | (5, 10, 5) | ƒê√®n ·ªü tr√™n cao, b√™n ph·∫£i |
| `lightColor` | M√†u √°nh s√°ng ch√≠nh | (1, 1, 1) | Tr·∫Øng thu·∫ßn |
| `ambientLight` | √Ånh s√°ng m√¥i tr∆∞·ªùng | (0.3, 0.3, 0.3) | S√°ng nh·∫π ƒë·ªÉ kh√¥ng c√≥ v√πng t·ªëi tuy·ªát ƒë·ªëi |
| `glClearColor` | M√†u n·ªÅn | (0.5, 0.7, 1.0) | Xanh da tr·ªùi nh·∫°t |

## üñºÔ∏è H·ªá th·ªëng Rendering

### üé® H√†m display() - H√†m v·∫Ω ch√≠nh
```cpp
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // X√≥a m√†n h√¨nh
    glLoadIdentity();                                   // Reset transformation
    
    // Set up camera
    glTranslatef(0.0f, 0.0f, -cameraDistance);
    glRotatef(cameraAngleX, 1.0f, 0.0f, 0.0f);
    glRotatef(cameraAngleY, 0.0f, 1.0f, 0.0f);
    
    // Draw everything
    drawScene();    // B√†n, m√°y pha c√† ph√™, c·ªëc (t·ª´ robot_simple.cpp)
    drawRobot();    // Robot (t·ª´ robot_simple.cpp)
    
    // V·∫Ω text status...
    
    glutSwapBuffers(); // Hi·ªÉn th·ªã frame ho√†n ch·ªânh
}
```

### üìù H·ªá th·ªëng hi·ªÉn th·ªã text
```cpp
// Text background - N·ªÅn ƒëen trong su·ªët
glColor4f(0.0f, 0.0f, 0.0f, 0.6f);        // ƒêen v·ªõi ƒë·ªô trong su·ªët 60%
glEnable(GL_BLEND);                        // B·∫≠t blending
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // C√¥ng th·ª©c blending
glBegin(GL_QUADS);
glVertex3f(-4.0f, 4.5f, 0.0f);            // G√≥c tr√™n tr√°i
glVertex3f(4.0f, 4.5f, 0.0f);             // G√≥c tr√™n ph·∫£i  
glVertex3f(4.0f, 3.5f, 0.0f);             // G√≥c d∆∞·ªõi ph·∫£i
glVertex3f(-4.0f, 3.5f, 0.0f);            // G√≥c d∆∞·ªõi tr√°i
glEnd();

// Status text - Text v√†ng
glColor3f(1.0f, 1.0f, 0.0f);              // M√†u v√†ng
glRasterPos3f(-3.8f, 4.2f, 0.0f);         // V·ªã tr√≠ text

const char* statusText[] = {
    "IDLE - Press SPACE to start making coffee",
    "Reaching for cup...",
    "Grabbing cup...", 
    "Turning to coffee machine...",
    "Pouring coffee...",
    "Returning to table...",
    "Placing cup down...",
    "Going home...",
    "FINISHED - Press R to reset, SPACE for another coffee"
};

const char* currentText = statusText[robot.phase]; // L·∫•y text theo pha hi·ªán t·∫°i
```

## ‚è∞ Animation Loop

### üîÑ H√†m timer() - V√≤ng l·∫∑p 60 FPS
```cpp
void timer(int value) {
    updateRobot();                    // C·∫≠p nh·∫≠t animation robot (t·ª´ robot_simple.cpp)
    glutPostRedisplay();              // Y√™u c·∫ßu v·∫Ω l·∫°i frame
    glutTimerFunc(16, timer, 0);      // L·∫∑p l·∫°i sau 16ms (~60 FPS)
}
```

**T√≠nh to√°n FPS:**
- 1000ms √∑ 16ms = 62.5 FPS
- ƒê·ªÉ c√≥ FPS kh√°c: `1000 √∑ FPS_mong_mu·ªën = th·ªùi_gian_delay`

## üéÆ C√°ch thay ƒë·ªïi camera v√† g√≥c nh√¨n

### 1. **Thay ƒë·ªïi v·ªã tr√≠ camera ban ƒë·∫ßu**
```cpp
// Trong ph·∫ßn global variables
float cameraAngleX = -45.0f;  // Nh√¨n t·ª´ tr√™n cao h∆°n
float cameraAngleY = 90.0f;   // Nh√¨n t·ª´ b√™n c·∫°nh
float cameraDistance = 20.0f; // Xa h∆°n ƒë·ªÉ nh√¨n to√†n c·∫£nh
```

### 2. **Thay ƒë·ªïi t·ªëc ƒë·ªô xoay camera**
```cpp
// Trong mouseMotion()
cameraAngleY += deltaX * 0.2f;  // Ch·∫≠m h∆°n (thay v√¨ 0.5f)
cameraAngleX += deltaY * 0.8f;  // Nhanh h∆°n (thay v√¨ 0.5f)
```

### 3. **Thay ƒë·ªïi gi·ªõi h·∫°n camera**
```cpp
// Trong mouseMotion()
if (cameraAngleX > 45.0f) cameraAngleX = 45.0f;   // Kh√¥ng cho nh√¨n qu√° cao
if (cameraAngleX < -60.0f) cameraAngleX = -60.0f; // Nh√¨n s√¢u h∆°n t·ª´ tr√™n
```

### 4. **Thay ƒë·ªïi zoom range**
```cpp
// Trong specialKeys()
if (cameraDistance < 8.0f) cameraDistance = 8.0f;   // G·∫ßn h∆°n
if (cameraDistance > 50.0f) cameraDistance = 50.0f; // Xa h∆°n
```

### 5. **Camera t·ª± ƒë·ªông xoay**
```cpp
// Th√™m v√†o timer() ƒë·ªÉ camera t·ª± xoay
void timer(int value) {
    updateRobot();
    
    // Camera t·ª± xoay ch·∫≠m
    cameraAngleY += 0.2f;
    if (cameraAngleY > 360.0f) cameraAngleY -= 360.0f;
    
    glutPostRedisplay();
    glutTimerFunc(16, timer, 0);
}
```

## üéÆ C√°ch thay ƒë·ªïi controls

### 1. **Th√™m ph√≠m m·ªõi**
```cpp
void keyboard(unsigned char key, int x, int y) {
    switch (key) {
        case ' ': // Space
            startCoffeeSequence();
            break;
            
        case 'r':
        case 'R': // Reset
            resetRobot();
            break;
            
        // Th√™m controls m·ªõi
        case 'p':
        case 'P': // Pause animation
            robot.moving = !robot.moving;
            std::cout << (robot.moving ? "Resume" : "Pause") << std::endl;
            break;
            
        case 'f':
        case 'F': // Fast mode
            const float FAST_SPEED = 0.03f;
            // Thay ƒë·ªïi ANIMATION_SPEED trong robot.h
            break;
            
        case 's':
        case 'S': // Slow mode
            const float SLOW_SPEED = 0.005f;
            break;
            
        case 27: // ESC
            exit(0);
            break;
    }
}
```

### 2. **Th√™m chu·ªôt ph·∫£i ƒë·ªÉ reset camera**
```cpp
void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON) {
        // Logic c≈©...
    } else if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN) {
        // Reset camera v·ªÅ v·ªã tr√≠ ban ƒë·∫ßu
        cameraAngleX = -25.0f;
        cameraAngleY = 45.0f;
        cameraDistance = 15.0f;
        std::cout << "üì∑ Camera reset to default position" << std::endl;
        glutPostRedisplay();
    }
}
```

### 3. **Th√™m wheel mouse cho zoom**
```cpp
// Th√™m h√†m m·ªõi
void mouseWheel(int wheel, int direction, int x, int y) {
    if (direction > 0) {
        cameraDistance -= 2.0f;  // Zoom in
        if (cameraDistance < 5.0f) cameraDistance = 5.0f;
    } else {
        cameraDistance += 2.0f;  // Zoom out  
        if (cameraDistance > 30.0f) cameraDistance = 30.0f;
    }
    glutPostRedisplay();
}

// ƒêƒÉng k√Ω trong main()
glutMouseWheelFunc(mouseWheel);
```

## üí° C√°ch thay ƒë·ªïi √°nh s√°ng v√† m√†u s·∫Øc

### 1. **Thay ƒë·ªïi v·ªã tr√≠ ƒë√®n**
```cpp
// Trong initGL()
GLfloat lightPos[] = {-5.0f, 15.0f, 10.0f, 1.0f}; // ƒê√®n b√™n tr√°i, cao h∆°n
GLfloat lightPos[] = {0.0f, 20.0f, 0.0f, 1.0f};    // ƒê√®n treo tr√™n ƒë·∫ßu
GLfloat lightPos[] = {10.0f, 5.0f, -5.0f, 1.0f};   // ƒê√®n b√™n ph·∫£i, th·∫•p
```

### 2. **Thay ƒë·ªïi m√†u √°nh s√°ng**
```cpp
// √Ånh s√°ng ·∫•m (v√†ng)
GLfloat lightColor[] = {1.0f, 0.9f, 0.7f, 1.0f};

// √Ånh s√°ng l·∫°nh (xanh)
GLfloat lightColor[] = {0.8f, 0.9f, 1.0f, 1.0f};

// √Ånh s√°ng ƒë·ªè
GLfloat lightColor[] = {1.0f, 0.5f, 0.5f, 1.0f};
```

### 3. **Thay ƒë·ªïi ƒë·ªô s√°ng m√¥i tr∆∞·ªùng**
```cpp
// T·ªëi h∆°n (dramatic)
GLfloat ambientLight[] = {0.1f, 0.1f, 0.1f, 1.0f};

// S√°ng h∆°n (soft)
GLfloat ambientLight[] = {0.5f, 0.5f, 0.5f, 1.0f};
```

### 4. **Thay ƒë·ªïi m√†u n·ªÅn**
```cpp
// N·ªÅn ƒëen (space theme)
glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

// N·ªÅn tr·∫Øng (clean theme)
glClearColor(1.0f, 1.0f, 1.0f, 1.0f);

// N·ªÅn ho√†ng h√¥n
glClearColor(1.0f, 0.6f, 0.2f, 1.0f);

// N·ªÅn xanh d∆∞∆°ng ƒë·∫≠m
glClearColor(0.2f, 0.3f, 0.8f, 1.0f);
```

### 5. **Th√™m nhi·ªÅu ƒë√®n**
```cpp
void initGL() {
    // B·∫≠t nhi·ªÅu ƒë√®n
    glEnable(GL_LIGHT0);  // ƒê√®n ch√≠nh
    glEnable(GL_LIGHT1);  // ƒê√®n ph·ª•
    
    // ƒê√®n 0 - ƒê√®n ch√≠nh
    GLfloat light0Pos[] = {5.0f, 10.0f, 5.0f, 1.0f};
    GLfloat light0Color[] = {1.0f, 1.0f, 1.0f, 1.0f};
    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light0Color);
    
    // ƒê√®n 1 - ƒê√®n t·∫°o b√≥ng
    GLfloat light1Pos[] = {-3.0f, 8.0f, -3.0f, 1.0f};
    GLfloat light1Color[] = {0.5f, 0.5f, 0.8f, 1.0f}; // Xanh nh·∫°t
    glLightfv(GL_LIGHT1, GL_POSITION, light1Pos);
    glLightfv(GL_LIGHT1, GL_DIFFUSE, light1Color);
}
```

## üñºÔ∏è C√°ch thay ƒë·ªïi giao di·ªán

### 1. **Thay ƒë·ªïi v·ªã tr√≠ text status**
```cpp
// Text ·ªü g√≥c tr√™n tr√°i
glRasterPos3f(-4.8f, 4.8f, 0.0f);

// Text ·ªü gi·ªØa m√†n h√¨nh
glRasterPos3f(-2.0f, 0.0f, 0.0f);

// Text ·ªü d∆∞·ªõi c√πng
glRasterPos3f(-3.8f, -4.0f, 0.0f);
```

### 2. **Thay ƒë·ªïi m√†u text**
```cpp
// Text ƒë·ªè
glColor3f(1.0f, 0.0f, 0.0f);

// Text xanh l√°
glColor3f(0.0f, 1.0f, 0.0f);

// Text tr·∫Øng
glColor3f(1.0f, 1.0f, 1.0f);

// Text v·ªõi hi·ªáu ·ª©ng nh·∫•p nh√°y
float blink = sin(glutGet(GLUT_ELAPSED_TIME) * 0.005f) * 0.5f + 0.5f;
glColor3f(1.0f, blink, 0.0f); // V√†ng nh·∫•p nh√°y
```

### 3. **Thay ƒë·ªïi font ch·ªØ**
```cpp
// Font nh·ªè h∆°n
glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, currentText[i]);

// Font to h∆°n
glutBitmapCharacter(GLUT_BITMAP_HELVETICA_24, currentText[i]);

// Font kh√°c
glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, currentText[i]);
glutBitmapCharacter(GLUT_BITMAP_9_BY_15, currentText[i]);
```

### 4. **Thay ƒë·ªïi n·ªÅn text**
```cpp
// N·ªÅn ƒë·ªè trong su·ªët
glColor4f(1.0f, 0.0f, 0.0f, 0.3f);

// N·ªÅn xanh d∆∞∆°ng ƒë·∫≠m
glColor4f(0.0f, 0.0f, 0.5f, 0.8f);

// Kh√¥ng c√≥ n·ªÅn (x√≥a ph·∫ßn v·∫Ω n·ªÅn)
// B·ªè qua ph·∫ßn glBegin(GL_QUADS)...glEnd()
```

### 5. **Th√™m FPS counter**
```cpp
// Th√™m v√†o display()
static int frameCount = 0;
static int lastTime = 0;
static float fps = 0.0f;

frameCount++;
int currentTime = glutGet(GLUT_ELAPSED_TIME);
if (currentTime - lastTime > 1000) { // C·∫≠p nh·∫≠t m·ªói gi√¢y
    fps = frameCount * 1000.0f / (currentTime - lastTime);
    frameCount = 0;
    lastTime = currentTime;
}

// Hi·ªÉn th·ªã FPS
char fpsText[50];
sprintf(fpsText, "FPS: %.1f", fps);
glRasterPos3f(3.0f, 4.2f, 0.0f);
for (int i = 0; fpsText[i] != '\0'; i++) {
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, fpsText[i]);
}
```

## üí° V√≠ d·ª• t√πy ch·ªânh

### V√≠ d·ª• 1: Camera th·ª© 3 (Third Person)
```cpp
// Camera theo sau robot t·ª´ ph√≠a sau
void thirdPersonCamera() {
    float robotX = 0.0f; // V·ªã tr√≠ robot
    float robotY = 1.0f;
    float robotZ = 0.0f;
    
    float cameraOffsetX = sin(robot.body * M_PI / 180.0f) * 8.0f;
    float cameraOffsetZ = cos(robot.body * M_PI / 180.0f) * 8.0f;
    
    glTranslatef(-cameraOffsetX, -3.0f, -cameraOffsetZ);
    glRotatef(-15.0f, 1.0f, 0.0f, 0.0f); // Nh√¨n h∆°i xu·ªëng
    glRotatef(-robot.body, 0.0f, 1.0f, 0.0f); // Xoay theo robot
}
```

### V√≠ d·ª• 2: Ch·∫ø ƒë·ªô debug v·ªõi nhi·ªÅu th√¥ng tin
```cpp
void drawDebugInfo() {
    glDisable(GL_LIGHTING);
    glColor3f(0.0f, 1.0f, 0.0f); // Xanh l√°
    
    char debugText[200];
    sprintf(debugText, "Phase: %d | Progress: %.2f | Body: %.1f¬∞", 
            robot.phase, robot.progress, robot.body);
    
    glRasterPos3f(-4.8f, -4.5f, 0.0f);
    for (int i = 0; debugText[i] != '\0'; i++) {
        glutBitmapCharacter(GLUT_BITMAP_9_BY_15, debugText[i]);
    }
    
    glEnable(GL_LIGHTING);
}

// Th√™m v√†o display()
drawDebugInfo();
```

### V√≠ d·ª• 3: Night mode
```cpp
void setupNightMode() {
    // N·ªÅn ƒëen
    glClearColor(0.05f, 0.05f, 0.1f, 1.0f);
    
    // √Ånh s√°ng y·∫øu, m√†u xanh
    GLfloat lightColor[] = {0.3f, 0.4f, 0.6f, 1.0f};
    GLfloat ambientLight[] = {0.05f, 0.05f, 0.1f, 1.0f};
    
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightColor);
    glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight);
}
```

### V√≠ d·ª• 4: Cinematic camera
```cpp
void cinematicCamera() {
    static float cinematicTime = 0.0f;
    cinematicTime += 0.02f;
    
    // Camera quay quanh robot
    float radius = 12.0f + sin(cinematicTime * 0.5f) * 3.0f; // Zoom in/out
    float angle = cinematicTime * 20.0f; // Xoay ch·∫≠m
    float height = 8.0f + cos(cinematicTime * 0.3f) * 2.0f; // L√™n xu·ªëng
    
    float camX = sin(angle * M_PI / 180.0f) * radius;
    float camZ = cos(angle * M_PI / 180.0f) * radius;
    
    glTranslatef(-camX, -height, -camZ);
    glRotatef(-20.0f, 1.0f, 0.0f, 0.0f);
    glRotatef(-angle, 0.0f, 1.0f, 0.0f);
}
```

### V√≠ d·ª• 5: Multiple viewports
```cpp
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    // Viewport 1 - Camera ch√≠nh (n·ª≠a tr√°i)
    glViewport(0, 0, 512, 768);
    glLoadIdentity();
    // Setup camera b√¨nh th∆∞·ªùng...
    drawScene();
    drawRobot();
    
    // Viewport 2 - Camera t·ª´ tr√™n (n·ª≠a ph·∫£i)
    glViewport(512, 0, 512, 768);
    glLoadIdentity();
    glTranslatef(0.0f, -15.0f, -5.0f);
    glRotatef(-90.0f, 1.0f, 0.0f, 0.0f); // Nh√¨n t·ª´ tr√™n xu·ªëng
    drawScene();
    drawRobot();
    
    glutSwapBuffers();
}
```

## ‚ö†Ô∏è Troubleshooting

### üêõ V·∫•n ƒë·ªÅ th∆∞·ªùng g·∫∑p

1. **M√†n h√¨nh ƒëen khi ch·∫°y**
   ```cpp
   // Ki·ªÉm tra:
   - glClearColor() c√≥ ƒë∆∞·ª£c g·ªçi kh√¥ng
   - Lighting c√≥ ƒë∆∞·ª£c setup ƒë√∫ng kh√¥ng
   - Camera distance c√≥ qu√° xa kh√¥ng (> 50)
   ```

2. **Camera kh√¥ng di chuy·ªÉn ƒë∆∞·ª£c**
   ```cpp
   // Ki·ªÉm tra:
   - mouseMotion() c√≥ ƒë∆∞·ª£c ƒëƒÉng k√Ω kh√¥ng: glutMotionFunc(mouseMotion)
   - mousePressed c√≥ ƒë∆∞·ª£c set true kh√¥ng
   - deltaX, deltaY c√≥ gi√° tr·ªã kh√¥ng
   ```

3. **Text kh√¥ng hi·ªÉn th·ªã**
   ```cpp
   // Ki·ªÉm tra:
   - glDisable(GL_LIGHTING) tr∆∞·ªõc khi v·∫Ω text
   - glColor3f() c√≥ ƒë∆∞·ª£c g·ªçi kh√¥ng
   - glRasterPos3f() trong ph·∫°m vi nh√¨n th·∫•y
   ```

4. **Robot kh√¥ng chuy·ªÉn ƒë·ªông**
   ```cpp
   // Ki·ªÉm tra:
   - timer() c√≥ ƒë∆∞·ª£c ƒëƒÉng k√Ω: glutTimerFunc(16, timer, 0)
   - updateRobot() c√≥ ƒë∆∞·ª£c g·ªçi trong timer()
   - robot.moving c√≥ = true kh√¥ng
   ```

5. **T·ªëc ƒë·ªô khung h√¨nh th·∫•p**
   ```cpp
   // Gi·∫£i ph√°p:
   - Gi·∫£m resolution: glutInitWindowSize(800, 600)
   - Gi·∫£m complexity: √çt polygon h∆°n
   - TƒÉng timer delay: glutTimerFunc(33, timer, 0) // 30 FPS
   ```

6. **√Ånh s√°ng kh√¥ng ho·∫°t ƒë·ªông**
   ```cpp
   // Ki·ªÉm tra:
   glEnable(GL_LIGHTING);     // B·∫≠t lighting
   glEnable(GL_LIGHT0);       // B·∫≠t ƒë√®n
   glEnable(GL_COLOR_MATERIAL); // B·∫≠t material
   glLightfv() ƒë∆∞·ª£c g·ªçi sau glEnable()
   ```

7. **Window kh√¥ng t·∫°o ƒë∆∞·ª£c**
   ```cpp
   // Ki·ªÉm tra:
   - glutInit() ƒë∆∞·ª£c g·ªçi ƒë·∫ßu ti√™n
   - glutInitDisplayMode() c√≥ ƒë·ªß flags
   - OpenGL driver c√≥ ƒë∆∞·ª£c c√†i ƒë·∫∑t kh√¥ng
   ```

### üîß Debug tips

```cpp
// Debug camera
printf("Camera: AngleX=%.1f, AngleY=%.1f, Distance=%.1f\n", 
       cameraAngleX, cameraAngleY, cameraDistance);

// Debug mouse
printf("Mouse: Pressed=%s, X=%d, Y=%d\n", 
       mousePressed ? "Yes" : "No", lastMouseX, lastMouseY);

// Debug OpenGL
GLenum error = glGetError();
if (error != GL_NO_ERROR) {
    printf("OpenGL Error: %d\n", error);
}

// Performance monitoring
static int frameCount = 0;
frameCount++;
if (frameCount % 60 == 0) {
    printf("60 frames rendered\n");
}
```

### üéØ Performance tips

```cpp
// Gi·∫£m chi ph√≠ rendering
1. S·ª≠ d·ª•ng displayLists cho v·∫≠t tƒ©nh
2. Gi·∫£m s·ªë polygon c·ªßa sphere, cylinder
3. T·∫Øt lighting khi kh√¥ng c·∫ßn: glDisable(GL_LIGHTING)
4. S·ª≠ d·ª•ng culling: glEnable(GL_CULL_FACE)
5. Gi·∫£m resolution window n·∫øu c·∫ßn
```

---
üìù **Ghi ch√∫**: File n√†y ƒë∆∞·ª£c ƒë·ªìng b·ªô v·ªõi coffee_robot.cpp version hi·ªán t·∫°i. Ki·ªÉm tra code m·ªõi nh·∫•t khi c√≥ thay ƒë·ªïi. 